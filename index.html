<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="stylesheet" href="styles.css">
<title>Interactive Node Graph</title>
</head>
<body>

<div id="viewport">
    <div id="world">
        <svg id="connections-layer"></svg>
        <div id="nodes-layer"></div>
        <div id="tools-layer"></div>
    </div>
</div>

<div id="ui-controls">
    <!-- <div class="row">
        <button class="btn-fab" id="zoom-in" title="Zoom In">+</button>
        <button class="btn-fab" id="zoom-out" title="Zoom Out">-</button> 
    </div> -->
    <div class="row">
        <button class="btn-fab" id="reset-view" title="Reset View">⟲</button>
        <button class="btn-fab primary" id="add-node" title="Add Node">+</button>
    </div>
</div>

<div id="debug">
    <span>Drag bg to pan • Scroll/Buttons to Zoom • Drag Nodes • Drag handles to connect</span>

    <!-- States -->
    <pre id="state-output"></pre>
</div>

<div id="modal-layer"></div>

<!-- Import monaco editor -->
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

<script>
    require.config({
      paths: {
        vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs'
      }
    });

    /** STATE & CONFIG */
    const state = {
        pan: { x: 0, y: 0 },
        scale: 1,
        snapScale: 20,
        minNodeWidth: 300,
        minNodeHeight: 200,
        nodes: [],
        connections: [], 
        
        // Interaction Flags
        isPanning: false,
        isDraggingNode: null,
        isResizingNode: null,
        isConnecting: false,
        
        // Tracking data
        lastMouse: { x: 0, y: 0 },
        dragOffset: { x: 0, y: 0 }, // Offset within node when dragging
        resizeStart: { w: 0, h: 0, x: 0, y: 0 },
        
        // Connection Logic
        connStartNode: null,
        connStartPort: null,
        tempPath: null,
        selectedConnId: null
    };

    // DOM Elements
    const viewport = document.getElementById('viewport');
    const world = document.getElementById('world');
    const nodesLayer = document.getElementById('nodes-layer');
    const connectionsLayer = document.getElementById('connections-layer');
    const toolsLayer = document.getElementById('tools-layer');

    /** INITIALIZATION */
    function init() {
        const data = localStorage.getItem('node-graph-v2');
        if (data) {
            const parsed = JSON.parse(data);
            state.nodes = parsed.nodes || [];
            state.connections = parsed.connections || [];
            state.pan = parsed.pan || { x: 0, y: 0 };
            state.scale = parsed.scale || 1;
            state.snapScale = parsed.snapScale || 20;
            console.log('connections', state.connections);
        } else {
            // Seeds
            // addNodeData(100, 100, 200, 150, "Welcome", "Drag me, resize me (bottom-right), or connect me.");
            // addNodeData(400, 250, 200, 150, "Target", "Click a line to delete it.");
        }
        applyTransform();
        state.nodes.forEach(renderNode);
        renderConnections();
    }

    const update_debug = () => {
        document.getElementById('state-output').textContent = JSON.stringify({
            ...state, 
            nodes: `[${state.nodes.length} nodes]`,
            connections: `[${state.connections.length} connections]`
        }, null, 2);
    };

    function saveData() {
        const data = {
            nodes: state.nodes,
            connections: state.connections,
            pan: state.pan,
            scale: state.scale,
            snapScale: state.snapScale
        };
        localStorage.setItem('node-graph-v2', JSON.stringify(data));
    }

    /** MODAL LOGIC */
    const open_modal = ({title, contentHtml, footerHtml, element, submitAction}) => {
        const modalLayer = document.getElementById('modal-layer');
        modalLayer.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <span class="modal-title">${title}</span>
                ${contentHtml}
                <button class="btn-close-modal">×</button>
                ${footerHtml ? `<div class="modal-footer">${footerHtml}</div>` : ''}
            </div>
        `;
        modalLayer.style.display = 'block';

        modalLayer.querySelector('.btn-close-modal').onclick = close_modal;
        modalLayer.querySelector('.modal-backdrop').onclick = close_modal;
        if (modalLayer.querySelector('.btn-cancel')) modalLayer.querySelector('.btn-cancel').onclick = close_modal;
        if (modalLayer.querySelector('.btn-submit')) {
            modalLayer.querySelector('.btn-submit').onclick = () => {
                if(submitAction) submitAction();
                close_modal();
            };
        }

        // Place the modal above, below, left, or right of the element depending on space
        if(element) {
            const rect = element.getBoundingClientRect();
            const modalContent = modalLayer.querySelector('.modal-content');
            modalContent.style.position = 'absolute';

            const space_from_top = rect.top;
            const space_from_bottom = window.innerHeight - rect.bottom;
            const space_from_left = rect.left;
            const space_from_right = window.innerWidth - rect.right;

            modalContent.style.left = (rect.left + rect.width / 2 - modalContent.offsetWidth / 2) + 'px';
            if (space_from_top > modalContent.offsetHeight) {
                modalContent.style.top = (rect.top - modalContent.offsetHeight - 10) + 'px';
                modalContent.classList.add('arrow-bottom');
                
            } else if (space_from_bottom > modalContent.offsetHeight) {
                modalContent.style.top = (rect.bottom + 10) + 'px';
                modalContent.classList.add('arrow-top');
            }
        }
    };

    const open_options_modal = ({title, element, option_btns}) => {
        const contentHtml = option_btns.map(btn => `<button class="btn-option ${btn.classes || ''}" data-id="${btn.id}">
            ${btn.icon ? `<span class="icon">${btn.icon}</span>` : ''}${btn.label}
        </button>`).join('');
        open_modal({element, title, contentHtml: `<div class="options-container">${contentHtml}</div>`});

        option_btns.forEach(btn => {
            const btnEl = document.querySelector(`.btn-option[data-id="${btn.id}"]`);
            if(btnEl) {
                btnEl.onclick = () => {
                    if(btn.onclick) btn.onclick();
                    close_modal();
                };
            }
        });
    };
    
    const close_modal = () => {
        const modalLayer = document.getElementById('modal-layer');
        modalLayer.style.display = 'none';
        modalLayer.innerHTML = '';
    };
    
    /** DOM HELPERS */
    const create_monaco_editor = (container, options) => {
        let editorInstance = null;
        require(['vs/editor/editor.main'], function() {
            editorInstance = monaco.editor.create(container, options);
        });
        return editorInstance;
    };
    
    function generateId() { return Math.random().toString(36).substr(2, 9); }
    
    function screenToWorld(sx, sy) {
        return {
            x: (sx - state.pan.x) / state.scale,
            y: (sy - state.pan.y) / state.scale
        };
    }

    function applyTransform() {
        world.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.scale})`;
        connectionsLayer.style.overflow = "visible";
    }

    const promise_chain = (funcs) => {
        return funcs.reduce((promise, func) => {
            return promise.then(result => func().then(Array.prototype.concat.bind(result)));
        }, Promise.resolve([]));
    };

    /** NODE LOGIC */
    function addNodeData(x, y, w, h, title, desc, type = 'default') {
        const node = { id: generateId(), x, y, w, h, title, desc, type };
        state.nodes.push(node);
        renderNode(node);
        saveData();
    }

    // Process connected default nodes
    const process_default_node = async ({targetNode, inputData}) => {
        const connectedOutputNodes = state.connections.filter(c => c.from === targetNode.id);
        const targetNodeEl = document.getElementById(targetNode.id);
        targetNodeEl.classList.add('processing'); // Highlight node during processing

        await new Promise(resolve => setTimeout(resolve, 500)); // Delay for demo purposes
        console.log(`Processing node '${targetNode.title}' with input:`, inputData);

        // Set the input data description
        const inputDescEl = targetNodeEl.querySelector('.node-desc#input-value');
        inputDescEl.value = formatDesc(JSON.stringify(inputData));

        const operations = targetNode.desc?.trim()?.split(';').map(op => op?.trim()) || [];
        if(operations.length > 0) {
            let outputData = inputData;
            operations.forEach(operation => {
                let funcBody = operation + `; return inputData;`;
                Object.keys(inputData).forEach(key => {
                    funcBody = funcBody
                        //.replaceAll(/\$all/g, 'inputData')?.trim()
                        .replaceAll(key, `inputData['${key}']`);
                });
                const func = new Function('inputData', funcBody);
                try {
                    let res = func(outputData);
                    console.log(`--> Output:`, res);
                    outputData = res;
                    targetNodeEl.classList.remove('processing');
                } catch (err) {
                    outputData = 'Error in operation';
                    targetNodeEl.classList.remove('processing');
                }
            });
            
            if (outputData !== undefined) {
                await promise_chain(connectedOutputNodes.map(conn => async () => {
                    const outputNode = state.nodes.find(n => n.id === conn.to);

                    // Pass output to connected output nodes
                    if(outputNode && outputNode.type === 'output') {
                        outputNode.desc = formatDesc(JSON.stringify(outputData), true);
                        const outputNodeEl = document.getElementById(outputNode.id);
                        const outputDescInput = outputNodeEl.querySelector('.node-desc');
                        outputDescInput.value = outputNode.desc;
                    }
                    // Pass output to connected default nodes
                    else if(outputNode && outputNode.type === 'default') {
                        await process_default_node({targetNode: outputNode, inputData: outputData});
                    }
                }));
            }
        }
    };

    function renderNode(node) {
        const el = document.createElement('div');
        el.className = 'node';
        el.id = node.id;
        el.dataset.type = node.type;
        el.style.left = node.x + 'px';
        el.style.top = node.y + 'px';
        el.style.width = node.w + 'px';
        el.style.height = node.h + 'px';

        el.innerHTML = `
            <div class="node-header">
                <input class="node-title" value="${node.title}">
                <button class="btn-options">⋮</button>
            </div>
            <div class="node-body">

                ${// Default Node Fields
                node.type === 'default' ? `` : ''}

                ${// Input Node Fields
                node.type === 'input' ? `
                <div class="new-node-field">
                    <input type="text" class="new-node-field-input" id="resource-name" placeholder="Name" />
                    <input type="number" class="new-node-field-input" id="resource-amount" placeholder="Value" />
                    <button class="btn-node-field-apply">Add</button>
                </div>
                ` : ''}

                ${// Output Node Fields
                node.type === 'output' ? `
                <textarea class="node-desc" id="output-value" placeholder="Output" disabled></textarea>
                ` : ''}

                ${node.type === 'input' ? `<div class="divider"></div>` : ''}

                ${node.type === 'default' ? `
                    <textarea class="node-desc" id="input-value" placeholder="Incoming data will be shown here." disabled></textarea>
                    <span class="node-desc-label">Operation <span class="node-desc-label-right">output = </span></span>
                    <textarea class="node-desc" id="operation-value" placeholder="Example: age * 2; $all + 5;">${node.desc}</textarea>
                ` : ''}

                ${node.type === 'input' ? `
                    <span class="node-desc-label">Input Data <span class="node-data-clear">Clear Data</span></span>
                    <textarea class="node-desc" id="resource-data" disabled placeholder="No data added.">${node.desc}</textarea>
                    <button class="btn-node-run">Run</button>
                ` : ''}
            </div>
            <div class="port port-t" data-p="t"></div>
            <div class="port port-r" data-p="r"></div>
            <div class="port port-b" data-p="b"></div>
            <div class="port port-l" data-p="l"></div>

            <div class="resize resize-rt" data-r="rt"></div>
            <div class="resize resize-rb" data-r="rb"></div>
            <div class="resize resize-lt" data-r="lt"></div>
            <div class="resize resize-lb" data-r="lb"></div>
        `;

        // Inputs
        const titleInput = el.querySelector('.node-title');
        const descInput = el.querySelector('.node-desc');
        
        // Update listeners
        titleInput.addEventListener('input', e => {
            state.nodes.find(n => n.id === node.id).title = e.target.value;
            saveData();
        });
        node.type === 'default' && descInput.addEventListener('input', e => {
            state.nodes.find(n => n.id === node.id).desc = e.target.value;
            saveData();
        });

        // Add onclick for Clear Data in input nodes
        node.type === 'input' && (el.querySelector('.node-data-clear').onclick = () => {
            const nodeRef = state.nodes.find(n => n.id === node.id);
            nodeRef.desc = '';
            descInput.value = '';
            saveData();
        });

        // Add onclick for the 'Add' button in input nodes to add resource data, which will be reflected in the desc textarea
        node.type === 'input' && (el.querySelector('.btn-node-field-apply').onclick = () => {
            const nameInput = el.querySelector('#resource-name');
            const amountInput = el.querySelector('#resource-amount');
            const name = nameInput.value.trim();
            const amount = parseFloat(amountInput.value);
            if(name && !isNaN(amount)) {
                // Format the resource data as a JSON-like string
                const nodeRef = state.nodes.find(n => n.id === node.id);
                const newResourceData = JSON.stringify({ [name]: amount });
                const currentDesc = nodeRef.desc.trim();
                nodeRef.desc += currentDesc ? `,${newResourceData}` : `${newResourceData}`;
                nodeRef.desc = formatDesc(nodeRef.desc);

                descInput.value = nodeRef.desc;
                nameInput.value = '';
                amountInput.value = '';
                saveData();
            }
        });

        // Add onclick for the 'Run' button in input nodes to simulate processing the resource data
        node.type === 'input' && (el.querySelector('.btn-node-run').onclick = async () => {
            const nodeRef = state.nodes.find(n => n.id === node.id);
            const incomingDataStr = nodeRef.desc.trim();
            if(!incomingDataStr) return;

            let incomingData;
            try { incomingData = JSON.parse(`{${incomingDataStr}}`) } 
            catch (err) { return alert('Invalid resource data format.') }

            // Find connected default nodes
            const connectedConns = state.connections.filter(c => c.from === node.id);
            // await connectedConns.forEach(async conn => {
            //     const targetNode = state.nodes.find(n => n.id === conn.to);
            //     if(targetNode && targetNode.type === 'default') {
            //         await process_default_node({targetNode, inputData: JSON.parse(JSON.stringify(incomingData))}); // deep copy
            //     }
            // });
            await promise_chain(connectedConns.map(conn => async () => {
                const targetNode = state.nodes.find(n => n.id === conn.to);
                if(targetNode && targetNode.type === 'default') {
                    await process_default_node({targetNode, inputData: JSON.parse(JSON.stringify(incomingData))}); // deep copy
                }
            }));
        });
        
        // Options Button
        el.querySelector('.btn-options').onclick = (e) => {
            open_options_modal({
                element: e.target,
                title: 'Node Options',
                option_btns: [
                    {
                        id: 'focus-node',
                        label: 'Focus Node',
                        onclick: () => focusNode(node.id)
                    },
                    { 
                        id: 'delete-node', 
                        classes: 'red',
                        label: 'Delete Node', 
                        onclick: () => deleteNode(node.id) 
                    }
                ]
            });
        };

        // Start Resizing
        el.querySelectorAll('.resize').forEach(r => {
            r.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                state.isResizingNode = node;
                state.resizeStart = { 
                    w: node.w, h: node.h, 
                    x: e.clientX, y: e.clientY,
                    handle: r.dataset.r
                };
            });
        });

        // Start Connecting
        el.querySelectorAll('.port').forEach(p => {
            p.addEventListener('pointerdown', (e) => startConnection(e, node.id));
        });

        // If clicking any input or textarea, stop propagation to prevent dragging
        el.querySelectorAll('input, textarea').forEach(inputEl => {
            if (inputEl.disabled) return;
            inputEl.addEventListener('pointerdown', (e) => e.stopPropagation());
            inputEl.oninput = () => {
                const nodeRef = state.nodes.find(n => n.id === node.id);
                if(inputEl.id === 'operation-value') nodeRef.desc = inputEl.value;
                else if(inputEl.id === 'resource-data') nodeRef.desc = inputEl.value;
                // else if(inputEl.id === 'output-value') nodeRef.desc = inputEl.value;
                
                saveData();
            };
        });
        
        nodesLayer.appendChild(el);
    }

    const formatDesc = (desc, format_like_json = false) => {
        let formatted = desc;
        if (format_like_json) {
            try {
                const json = JSON.parse(formatted);
                formatted = JSON.stringify(json, null, 2);
            } catch (e) {
                console.warn('Failed to format as JSON:', e);
            }
        }
        else {
            formatted = formatted.replace(/,/g, ', '); // Add spaces after commas for readability
            formatted = formatted.replace(/:/g, ': '); // Add spaces after colons for readability
            formatted = formatted.replace(/{/g, '').replace(/}/g, ''); // Remove braces for cleaner display
            formatted = formatted.replace(/\s+/g, ' ').trim(); // remove any extra spaces
        }

        return formatted;
    };

    const focusNode = (id) => {
        const node = state.nodes.find(n => n.id === id);
        if(node) {
            const vpRect = viewport.getBoundingClientRect();

            // Zoom
            const scaleX = vpRect.width / (node.w * 2);
            const scaleY = vpRect.height / (node.h * 2);
            state.scale = Math.min(scaleX, scaleY);

            // Pan
            const targetX = -node.x * state.scale + vpRect.width / 2 - (node.w * state.scale) / 2;
            const targetY = -node.y * state.scale + vpRect.height / 2 - (node.h * state.scale) / 2;
            state.pan.x = targetX;
            state.pan.y = targetY;
            
            applyTransform();
            saveData();
        }
    };

    function deleteNode(id) {
        state.nodes = state.nodes.filter(n => n.id !== id);
        state.connections = state.connections.filter(c => c.from !== id && c.to !== id);
        document.getElementById(id).remove();
        renderConnections();
        saveData();
    }

    /** CONNECTION LOGIC */
    function startConnection(e, nodeId) {
        e.stopPropagation();
        state.isConnecting = true;
        state.connStartNode = state.nodes.find(n => n.id === nodeId);
        state.connStartPort = e.target;

        // Create temp path
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("class", "connection-line");
        path.style.strokeDasharray = "12";
        connectionsLayer.appendChild(path);
        state.tempPath = path;
    }

    function updateTempConnection(e) {
        if(!state.tempPath) return;
        const mp = screenToWorld(e.clientX, e.clientY);
        const start = getCenter({
            x: state.connStartPort.offsetLeft + state.connStartNode.x, 
            y: state.connStartPort.offsetTop + state.connStartNode.y, 
            w: state.connStartPort.classList.contains('port-l') || state.connStartPort.classList.contains('port-r') ? 10 : 2,
            h: state.connStartPort.classList.contains('port-t') || state.connStartPort.classList.contains('port-b') ? 10 : 2
        });
        const d = `M ${start.x} ${start.y} L ${mp.x} ${mp.y}`;
        state.tempPath.setAttribute("d", d);
    }

    function endConnection(e) {
        const targetEl = document.elementFromPoint(e.clientX, e.clientY);
        const targetNodeEl = targetEl ? targetEl.closest('.node') : null;

        if (targetNodeEl && targetNodeEl.id !== state.connStartNode.id) {
            // Create connection
            const newConn = {
                id: generateId(),
                from: state.connStartNode.id,
                to: targetNodeEl.id
            };
            // Prevent duplicates
            const exists = state.connections.find(c => 
                (c.from === newConn.from && c.to === newConn.to) ||
                (c.from === newConn.to && c.to === newConn.from)
            );

            if(!exists) {
                state.connections.push(newConn);
                saveData();
            }
        }
        
        if(state.tempPath) state.tempPath.remove();
        state.isConnecting = false;
        state.tempPath = null;
        state.connStartNode = null;
        state.connStartPort = null;
        renderConnections();
    }

    function deleteConnection(connId) {
        state.connections = state.connections.filter(c => c.id !== connId);
        state.selectedConnId = null;
        renderConnections();
        saveData();
    }

    const reverseConnectionFlow = (connId) => {
        const conn = state.connections.find(c => c.id === connId);
        if(conn) {
            const temp = conn.from;
            conn.from = conn.to;
            conn.to = temp;
            state.selectedConnId = null;
            renderConnections();
            saveData();
        }
    };

    function selectConnection(connId) {
        state.selectedConnId = connId;
        renderConnections(); // Redraws to show selected state & button
    }

    /** RENDERING CONNECTIONS */
    function renderConnections() {
        const is_selecting = state.selectedConnId;

        // If selecting, only remove selected connection
        if (is_selecting) {
            connectionsLayer.querySelectorAll('.connection-group').forEach(g => {
                if (g.getAttribute('data-connection-id') === state.selectedConnId) g.remove();
                else {
                    g.classList.remove('selected');
                }
            });
            toolsLayer.innerHTML = '';
        }
        // Otherwise, clear all & redraw
        else {
            connectionsLayer.innerHTML = '';
            toolsLayer.innerHTML = '';
        }

        state.connections.forEach(conn => {
            let skip = false;
            if (is_selecting) skip = conn.id !== state.selectedConnId;

            if (!skip) {
                const n1 = state.nodes.find(n => n.id === conn.from);
                const n2 = state.nodes.find(n => n.id === conn.to);
                if(!n1 || !n2) return;

                // Calculate points
                const c1 = getCenter(n1);
                const c2 = getCenter(n2);
                
                // Logic to calculate start/end based on relative position (snap to edges)
                const p1 = getSnapPoint(c1, c2);
                const p2 = getSnapPoint(c2, c1);
                
                // Bezier Control Points
                const dx = Math.abs(p1.x - p2.x);
                const dy = Math.abs(p1.y - p2.y);
                const cp1 = { x: (p1.x + p2.x)/2, y: p1.y }; 
                const cp2 = { x: (p1.x + p2.x)/2, y: p2.y };
                
                // Use a smoother curve heuristic
                const tension = 0.25;
                const metaX = Math.abs(p1.x - p2.x) * tension;
                const metaY = Math.abs(p1.y - p2.y) * tension;
                
                // Horizontal vs Vertical dominance
                let cx1, cy1, cx2, cy2;
                if(dx >= dy) {
                    // Horizontalish
                    cx1 = p1.x + (p1.x < p2.x ? metaX : -metaX);
                    cy1 = p1.y;
                    cx2 = p2.x + (p2.x < p1.x ? metaX : -metaX);
                    cy2 = p2.y;
                }
                else {
                    // Verticalish
                    cx1 = p1.x;
                    cy1 = p1.y + (p1.y < p2.y ? metaY : -metaY);
                    cx2 = p2.x;
                    cy2 = p2.y + (p2.y < p1.y ? metaY : -metaY);
                }

                const d = `M ${p1.x} ${p1.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${p2.x} ${p2.y}`;

                // Create Group
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("class", `connection-group ${state.selectedConnId === conn.id ? 'selected' : ''}`);
                g.setAttribute("data-connection-id", conn.id);
                g.onclick = (e) => {
                    e.stopPropagation();
                    selectConnection(conn.id);
                };

                // Hitbox (thick)
                const pathHit = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathHit.setAttribute("d", d);
                pathHit.setAttribute("class", "connection-hitbox");

                // Visible Line
                const pathLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathLine.setAttribute("d", d);
                pathLine.setAttribute("class", "connection-line");

                g.appendChild(pathHit);
                g.appendChild(pathLine);
                connectionsLayer.appendChild(g);

                // If selected, Draw Delete Button at mid point (approx Bezier t=0.5)
                if (state.selectedConnId === conn.id) {
                    // simple midpoint approximation
                    const midX = 0.125 * p1.x + 0.375 * cx1 + 0.375 * cx2 + 0.125 * p2.x;
                    const midY = 0.125 * p1.y + 0.375 * cy1 + 0.375 * cy2 + 0.125 * p2.y;
                    
                    const btn = document.createElement('div');
                    btn.className = 'conn-options-btn';
                    btn.innerHTML = '⋮';
                    btn.style.left = midX + 'px';
                    btn.style.top = midY + 'px';
                    btn.style.display = 'flex';
                    btn.title = 'Connection Options';
                    
                    // Prevent bubbling to viewport (which deselects)
                    btn.onpointerdown = (e) => e.stopPropagation(); 
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        open_options_modal({
                            element: btn,
                            title: 'Connection Options',
                            option_btns: [
                                {
                                    id: 'reverse-conn-flow', 
                                    classes: 'blue',
                                    label: 'Reverse Connection Flow',
                                    onclick: () => reverseConnectionFlow(conn.id)
                                },
                                { 
                                    id: 'delete-conn', 
                                    classes: 'red',
                                    label: 'Delete Connection', 
                                    onclick: () => deleteConnection(conn.id) 
                                }
                            ]
                        });
                    };
                    
                    toolsLayer.appendChild(btn);
                }
            }
        });
    }

    function getCenter(n) { return { x: n.x + n.w/2, y: n.y + n.h/2, w: n.w, h: n.h }; }
    
    function getSnapPoint(source, target) {
        // Find intersection of line (source center -> target center) with source box
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        
        // simple 4-quadrant snap
        // if(Math.abs(dx) / (source.w/2) > Math.abs(dy) / (source.h/2)) {
        //     // Left or Right
        //     return { x: source.x + (dx > 0 ? source.w/2 : -source.w/2), y: source.y };
        // } else {
        //     // Top or Bottom
        //     return { x: source.x, y: source.y + (dy > 0 ? source.h/2 : -source.h/2) };
        // }

        // Even more precise by finding the shortest line to each rect edge
        const slopes = [
            { x: source.x + source.w / 2, y: source.y + (dy / dx) * (source.w / 2) }, // Right
            { x: source.x - source.w / 2, y: source.y - (dy / dx) * (source.w / 2) }, // Left
            { x: source.x + (dx / dy) * (source.h / 2), y: source.y + source.h / 2 }, // Bottom
            { x: source.x - (dx / dy) * (source.h / 2), y: source.y - source.h / 2 }  // Top
        ];
        // Filter valid points (within box edges)
        const validPoints = slopes.filter(p => {
            return (p.x >= source.x - source.w / 2 && p.x <= source.x + source.w / 2 &&
                    p.y >= source.y - source.h / 2 && p.y <= source.y + source.h / 2);
        });
        // Find closest valid point to target
        let closestPoint = validPoints[0];
        let minDist = Infinity;
        validPoints.forEach(p => {
            const dist = Math.hypot(p.x - target.x, p.y - target.y);
            if (dist < minDist) {
                minDist = dist;
                closestPoint = p;
            }
        });

        // offset to edge
        const offset = 5;
        if (closestPoint.x === source.x + source.w / 2) closestPoint.x += offset; // Right edge
        else if (closestPoint.x === source.x - source.w / 2) closestPoint.x -= offset; // Left edge
        else if (closestPoint.y === source.y + source.h / 2) closestPoint.y += offset; // Bottom edge
        else if (closestPoint.y === source.y - source.h / 2) closestPoint.y -= offset; // Top edge

        return closestPoint;
    }

    function getPortPoint(n) {
        // For drag start, just use center, it snaps later
        return { x: n.x + n.w/2, y: n.y + n.h/2 };
    }


    /** GLOBAL INPUT HANDLERS */
    viewport.addEventListener('pointerdown', e => {
        // 1. Check Resizing
        if(state.isResizingNode) return;

        // 2. Check Node Drag
        const nodeEl = e.target.closest('.node');
        if(nodeEl) {
            const node = state.nodes.find(n => n.id === nodeEl.id);
            // nodeEl.classList.add('is-dragging');
            state.isDraggingNode = node;
            const wp = screenToWorld(e.clientX, e.clientY);
            state.dragOffset = { x: wp.x - node.x, y: wp.y - node.y };
            if(state.selectedConnId) { state.selectedConnId = null; renderConnections(); } // Deselect connection
            return;
        }

        // 3. Pan Background
        if(e.target === viewport || e.target === nodesLayer || e.target === world || e.target.id === 'connections-layer') {
            state.isPanning = true;
            state.lastMouse = { x: e.clientX, y: e.clientY };
            // Deselect connection
            if(state.selectedConnId) { state.selectedConnId = null; renderConnections(); }
        }
    });

    window.addEventListener('pointermove', e => {
        const mx = e.clientX;
        const my = e.clientY;

        if (state.isResizingNode) {
            const node = state.isResizingNode;
            const dx = (mx - state.resizeStart.x) / state.scale;
            const dy = (my - state.resizeStart.y) / state.scale;

            const handle = state.resizeStart.handle;
            if (handle === 'r') {
                node.w = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w + dx))/state.snapScale)*state.snapScale;
            } 
            else if (handle === 'b') {
                node.h = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h + dy))/state.snapScale)*state.snapScale;
            } 
            else if (handle === 'l') {
                const newW = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w - dx))/state.snapScale)*state.snapScale;
                const deltaW = newW - node.w;
                node.w = newW;
                node.x -= deltaW;
            } 
            else if (handle === 't') {
                const newH = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h - dy))/state.snapScale)*state.snapScale;
                const deltaH = newH - node.h;
                node.h = newH;
                node.y -= deltaH;
            }
            else if (handle === 'rt') {
                node.w = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w + dx))/state.snapScale)*state.snapScale;
                const newH = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h - dy))/state.snapScale)*state.snapScale;
                const deltaH = newH - node.h;
                node.h = newH;
                node.y -= deltaH;
            } 
            else if (handle === 'lt') {
                const newW = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w - dx))/state.snapScale)*state.snapScale;
                const deltaW = newW - node.w;
                node.w = newW;
                node.x -= deltaW;
                const newH = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h - dy))/state.snapScale)*state.snapScale;
                const deltaH = newH - node.h;
                node.h = newH;
                node.y -= deltaH;
            }
            else if (handle === 'rb') {
                node.w = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w + dx))/state.snapScale)*state.snapScale;
                node.h = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h + dy))/state.snapScale)*state.snapScale;
            } 
            else if (handle === 'lb') {
                const newW = Math.round((Math.max(state.minNodeWidth, state.resizeStart.w - dx))/state.snapScale)*state.snapScale;
                const deltaW = newW - node.w;
                node.w = newW;
                node.x -= deltaW;
                node.h = Math.round((Math.max(state.minNodeHeight, state.resizeStart.h + dy))/state.snapScale)*state.snapScale;
            }

            const el = document.getElementById(node.id);
            el.style.width = node.w + 'px';
            el.style.height = node.h + 'px';
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            
            renderConnections(); // Update lines in real time
        }
        else if (state.isDraggingNode) {
            const nodeEl = document.getElementById(state.isDraggingNode.id);
            nodeEl.classList.add('is-dragging');
            const wp = screenToWorld(mx, my);
            state.isDraggingNode.x = wp.x - state.dragOffset.x;
            state.isDraggingNode.y = wp.y - state.dragOffset.y;
            
            // Snap to 10px
            state.isDraggingNode.x = Math.round(state.isDraggingNode.x/state.snapScale)*state.snapScale;
            state.isDraggingNode.y = Math.round(state.isDraggingNode.y/state.snapScale)*state.snapScale;

            const el = document.getElementById(state.isDraggingNode.id);
            el.style.left = state.isDraggingNode.x + 'px';
            el.style.top = state.isDraggingNode.y + 'px';
            
            renderConnections();
        } 
        else if (state.isPanning) {
            const dx = mx - state.lastMouse.x;
            const dy = my - state.lastMouse.y;
            state.pan.x += dx;
            state.pan.y += dy;
            state.lastMouse = { x: mx, y: my };
            applyTransform();
        }
        else if (state.isConnecting) {
            updateTempConnection(e);
        }

        update_debug();
    });

    window.addEventListener('pointerup', e => {
        if (state.isDraggingNode || state.isResizingNode) {
            const el = document.getElementById(state.isDraggingNode ? state.isDraggingNode.id : state.isResizingNode.id);
            el.classList.remove('is-dragging');
            saveData();
        }
        if (state.isConnecting) {
            endConnection(e);
        }
        state.isDraggingNode = null;
        state.isResizingNode = null;
        state.isPanning = false;
    });

    /** ZOOMING */
    function zoom(delta, centerX, centerY) {
        const newScale = Math.min(Math.max(0.1, state.scale + delta), 5);
        if(newScale === state.scale) return;

        // Zoom towards center
        const worldX = (centerX - state.pan.x) / state.scale;
        const worldY = (centerY - state.pan.y) / state.scale;

        state.scale = newScale;
        state.pan.x = centerX - worldX * state.scale;
        state.pan.y = centerY - worldY * state.scale;
        
        applyTransform();
        saveData();
    }

    viewport.addEventListener('wheel', e => {
        e.preventDefault();
        const delta = -e.deltaY * 0.001;
        zoom(delta, e.clientX, e.clientY);
    }, { passive: false });

    let lastTouchDist = null;
    viewport.addEventListener('touchmove', e => {
        if(e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            if(lastTouchDist !== null) {
                const delta = (dist - lastTouchDist) * 0.01;
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                zoom(delta, centerX, centerY);
            }
            lastTouchDist = dist;
        }
    }, { passive: false });

    /** UI CONTROLS */
    document.getElementById('add-node').onclick = (e) => {
        const wp = screenToWorld(viewport.clientWidth/2, viewport.clientHeight/2);
        open_options_modal({
            element: e.target,
            title: 'Add Node',
            option_btns: [
                {
                    id: 'add-input-node', 
                    classes: 'blue',
                    label: 'Add Input Node', 
                    onclick: () => addNodeData(wp.x - 75, wp.y - 50, 300, 200, "New Input Node", "", 'input') 
                },
                {
                    id: 'add-output-node', 
                    classes: 'blue',
                    label: 'Add Output Node', 
                    onclick: () => addNodeData(wp.x - 75, wp.y - 50, 300, 200, "New Output Node", "", 'output') 
                },
                { 
                    id: 'add-default-node', 
                    classes: 'green',
                    label: 'Add Default Node', 
                    onclick: () => addNodeData(wp.x - 75, wp.y - 50, 300, 200, "New Default Node", "", 'default') 
                }
            ]
        });
    };

    document.getElementById('reset-view').onclick = () => {
        state.pan = { x: 0, y: 0 };
        state.scale = 1;
        applyTransform();
        saveData();
    };

    // Keyboard delete for selected connection
    window.addEventListener('keydown', (e) => {
        if((e.key === 'Delete' || e.key === 'Backspace') && state.selectedConnId) {
            deleteConnection(state.selectedConnId);
        }
    });

    // Run
    init();

</script>
</body>
</html>